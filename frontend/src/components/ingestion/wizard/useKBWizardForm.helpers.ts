/**
 * Helper hooks for the KB Wizard form to keep the main hook lean.
 */

import { useCallback, useMemo, useRef, useState } from "react";
import { SourceType } from "../../../types/ingestion";
import { generateKbId, canProceed as validateStep } from "./wizardUtils";

export type WizardStep = "basic" | "source" | "config" | "review";

export interface SubmitParams {
  kbId: string;
  name: string;
  description: string;
  sourceType: SourceType;
  urls: string[];
  urlPrefix: string;
  videoUrls: string[];
  pdfLocalPaths: string[];
  pdfUrls: string[];
  pdfFolderPath: string;
  markdownFolderPath: string;
}

export interface SourceInputValues {
  urls: string[];
  urlPrefix: string;
  videoUrls: string[];
  pdfLocalPaths: string[];
  pdfUrls: string[];
  pdfFolderPath: string;
  markdownFolderPath: string;
}

export function useWebsiteInputs() {
  const [urls, setUrls] = useState<string[]>([""]);
  const [urlPrefix, setUrlPrefix] = useState("");
  return { urls, setUrls, urlPrefix, setUrlPrefix };
}

export function useYouTubeInputs() {
  const [videoUrls, setVideoUrls] = useState<string[]>([""]);
  return { videoUrls, setVideoUrls };
}

export function usePDFInputs() {
  const [pdfLocalPaths, setPdfLocalPaths] = useState<string[]>([""]);
  const [pdfUrls, setPdfUrls] = useState<string[]>([""]);
  const [pdfFolderPath, setPdfFolderPath] = useState("");
  return {
    pdfLocalPaths,
    setPdfLocalPaths,
    pdfUrls,
    setPdfUrls,
    pdfFolderPath,
    setPdfFolderPath,
  };
}

export function useMarkdownInputs() {
  const [markdownFolderPath, setMarkdownFolderPath] = useState("");
  return { markdownFolderPath, setMarkdownFolderPath };
}

export function useKBWizardState() {
  const [step, setStep] = useState<WizardStep>("basic");
  const [kbId, setKbId] = useState("");
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [sourceType, setSourceType] = useState<SourceType>("website");
  const autoGeneratedKbIdRef = useRef("");

  const handleNameChange = useCallback((value: string) => {
    setName(value);
    setKbId((currentKbId) => {
      const lastAutoGenerated = autoGeneratedKbIdRef.current;
      const derivedKbId = generateKbId(value);
      const shouldOverwrite =
        currentKbId === "" || currentKbId === lastAutoGenerated;
      autoGeneratedKbIdRef.current = derivedKbId;
      return shouldOverwrite ? derivedKbId : currentKbId;
    });
  }, []);

  return {
    step,
    setStep,
    kbId,
    setKbId,
    name,
    description,
    setDescription,
    sourceType,
    setSourceType,
    setName: handleNameChange,
  };
}

export interface SourceInputArgs {
  websiteInputs: ReturnType<typeof useWebsiteInputs>;
  youtubeInputs: ReturnType<typeof useYouTubeInputs>;
  pdfInputs: ReturnType<typeof usePDFInputs>;
  markdownInputs: ReturnType<typeof useMarkdownInputs>;
}

export function useSourceInputValues({
  websiteInputs,
  youtubeInputs,
  pdfInputs,
  markdownInputs,
}: SourceInputArgs): SourceInputValues {
  return useMemo<SourceInputValues>(() => {
    return {
      urls: websiteInputs.urls,
      urlPrefix: websiteInputs.urlPrefix,
      videoUrls: youtubeInputs.videoUrls,
      pdfLocalPaths: pdfInputs.pdfLocalPaths,
      pdfUrls: pdfInputs.pdfUrls,
      pdfFolderPath: pdfInputs.pdfFolderPath,
      markdownFolderPath: markdownInputs.markdownFolderPath,
    };
  }, [
    websiteInputs.urls,
    websiteInputs.urlPrefix,
    youtubeInputs.videoUrls,
    pdfInputs.pdfLocalPaths,
    pdfInputs.pdfUrls,
    pdfInputs.pdfFolderPath,
    markdownInputs.markdownFolderPath,
  ]);
}

export interface ValidationPayloadArgs {
  step: WizardStep;
  kbId: string;
  name: string;
  sourceType: SourceType;
  sourceInputValues: SourceInputValues;
}

export function useValidationPayload({
  step,
  kbId,
  name,
  sourceType,
  sourceInputValues,
}: ValidationPayloadArgs) {
  return useMemo(
    () => ({
      step,
      kbId,
      name,
      sourceType,
      ...sourceInputValues,
    }),
    [step, kbId, name, sourceType, sourceInputValues]
  );
}

export function useWizardValidation(
  payload: ReturnType<typeof useValidationPayload>
) {
  return useCallback(() => validateStep(payload), [payload]);
}
